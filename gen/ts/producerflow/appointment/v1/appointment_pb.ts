// @generated by protoc-gen-es v1.8.0 with parameter "target=ts,import_extension=none"
// @generated from file producerflow/appointment/v1/appointment.proto (package producerflow.appointment.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * Eligibility status of the appointment.
 *
 * @generated from enum producerflow.appointment.v1.EligibilityStatus
 */
export enum EligibilityStatus {
  /**
   * @generated from enum value: ELIGIBILITY_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ELIGIBILITY_STATUS_ELIGIBLE = 1;
   */
  ELIGIBLE = 1,

  /**
   * @generated from enum value: ELIGIBILITY_STATUS_INELIGIBLE = 2;
   */
  INELIGIBLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EligibilityStatus)
proto3.util.setEnumType(EligibilityStatus, "producerflow.appointment.v1.EligibilityStatus", [
  { no: 0, name: "ELIGIBILITY_STATUS_UNSPECIFIED" },
  { no: 1, name: "ELIGIBILITY_STATUS_ELIGIBLE" },
  { no: 2, name: "ELIGIBILITY_STATUS_INELIGIBLE" },
]);

/**
 * Processing status of the appointment.
 *
 * @generated from enum producerflow.appointment.v1.ProcessingStatus
 */
export enum ProcessingStatus {
  /**
   * @generated from enum value: PROCESSING_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROCESSING_STATUS_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * @generated from enum value: PROCESSING_STATUS_APPOINTED = 2;
   */
  APPOINTED = 2,

  /**
   * @generated from enum value: PROCESSING_STATUS_TERMINATED = 3;
   */
  TERMINATED = 3,

  /**
   * @generated from enum value: PROCESSING_STATUS_REJECTED = 4;
   */
  REJECTED = 4,

  /**
   * @generated from enum value: PROCESSING_STATUS_MISSING_LICENSE = 5;
   */
  MISSING_LICENSE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ProcessingStatus)
proto3.util.setEnumType(ProcessingStatus, "producerflow.appointment.v1.ProcessingStatus", [
  { no: 0, name: "PROCESSING_STATUS_UNSPECIFIED" },
  { no: 1, name: "PROCESSING_STATUS_IN_PROGRESS" },
  { no: 2, name: "PROCESSING_STATUS_APPOINTED" },
  { no: 3, name: "PROCESSING_STATUS_TERMINATED" },
  { no: 4, name: "PROCESSING_STATUS_REJECTED" },
  { no: 5, name: "PROCESSING_STATUS_MISSING_LICENSE" },
]);

/**
 * Type of appointment.
 *
 * @generated from enum producerflow.appointment.v1.AppointmentType
 */
export enum AppointmentType {
  /**
   * @generated from enum value: APPOINTMENT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: APPOINTMENT_TYPE_REGISTRY = 1;
   */
  REGISTRY = 1,

  /**
   * @generated from enum value: APPOINTMENT_TYPE_UP_FRONT = 2;
   */
  UP_FRONT = 2,

  /**
   * @generated from enum value: APPOINTMENT_TYPE_JUST_IN_TIME = 3;
   */
  JUST_IN_TIME = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AppointmentType)
proto3.util.setEnumType(AppointmentType, "producerflow.appointment.v1.AppointmentType", [
  { no: 0, name: "APPOINTMENT_TYPE_UNSPECIFIED" },
  { no: 1, name: "APPOINTMENT_TYPE_REGISTRY" },
  { no: 2, name: "APPOINTMENT_TYPE_UP_FRONT" },
  { no: 3, name: "APPOINTMENT_TYPE_JUST_IN_TIME" },
]);

/**
 * Request to create a new appointment.
 *
 * @generated from message producerflow.appointment.v1.RequestAppointmentRequest
 */
export class RequestAppointmentRequest extends Message<RequestAppointmentRequest> {
  /**
   * Required. License number to appoint.
   *
   * @generated from field: string license_number = 1;
   */
  licenseNumber = "";

  constructor(data?: PartialMessage<RequestAppointmentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.RequestAppointmentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "license_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestAppointmentRequest {
    return new RequestAppointmentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestAppointmentRequest {
    return new RequestAppointmentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestAppointmentRequest {
    return new RequestAppointmentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RequestAppointmentRequest | PlainMessage<RequestAppointmentRequest> | undefined, b: RequestAppointmentRequest | PlainMessage<RequestAppointmentRequest> | undefined): boolean {
    return proto3.util.equals(RequestAppointmentRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.RequestAppointmentResponse
 */
export class RequestAppointmentResponse extends Message<RequestAppointmentResponse> {
  /**
   * The ID of the created appointment.
   *
   * @generated from field: string appointment_id = 1;
   */
  appointmentId = "";

  /**
   * Processing status of the appointment request.
   *
   * @generated from field: producerflow.appointment.v1.ProcessingStatus processing_status = 2;
   */
  processingStatus = ProcessingStatus.UNSPECIFIED;

  /**
   * If the appointment was rejected or ineligible, these reasons explain why.
   *
   * @generated from field: repeated string not_eligible_reasons = 3;
   */
  notEligibleReasons: string[] = [];

  constructor(data?: PartialMessage<RequestAppointmentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.RequestAppointmentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "processing_status", kind: "enum", T: proto3.getEnumType(ProcessingStatus) },
    { no: 3, name: "not_eligible_reasons", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestAppointmentResponse {
    return new RequestAppointmentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestAppointmentResponse {
    return new RequestAppointmentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestAppointmentResponse {
    return new RequestAppointmentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RequestAppointmentResponse | PlainMessage<RequestAppointmentResponse> | undefined, b: RequestAppointmentResponse | PlainMessage<RequestAppointmentResponse> | undefined): boolean {
    return proto3.util.equals(RequestAppointmentResponse, a, b);
  }
}

/**
 * Request to retrieve an appointment by ID.
 *
 * @generated from message producerflow.appointment.v1.GetAppointmentRequest
 */
export class GetAppointmentRequest extends Message<GetAppointmentRequest> {
  /**
   * Required. The ID of the appointment to retrieve.
   *
   * @generated from field: string appointment_id = 1;
   */
  appointmentId = "";

  constructor(data?: PartialMessage<GetAppointmentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetAppointmentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppointmentRequest {
    return new GetAppointmentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppointmentRequest {
    return new GetAppointmentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppointmentRequest {
    return new GetAppointmentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppointmentRequest | PlainMessage<GetAppointmentRequest> | undefined, b: GetAppointmentRequest | PlainMessage<GetAppointmentRequest> | undefined): boolean {
    return proto3.util.equals(GetAppointmentRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.GetAppointmentResponse
 */
export class GetAppointmentResponse extends Message<GetAppointmentResponse> {
  /**
   * The appointment details.
   *
   * @generated from field: producerflow.appointment.v1.Appointment appointment = 1;
   */
  appointment?: Appointment;

  constructor(data?: PartialMessage<GetAppointmentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetAppointmentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment", kind: "message", T: Appointment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppointmentResponse {
    return new GetAppointmentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppointmentResponse {
    return new GetAppointmentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppointmentResponse {
    return new GetAppointmentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppointmentResponse | PlainMessage<GetAppointmentResponse> | undefined, b: GetAppointmentResponse | PlainMessage<GetAppointmentResponse> | undefined): boolean {
    return proto3.util.equals(GetAppointmentResponse, a, b);
  }
}

/**
 * Request to list appointments, optionally filtered by processing status.
 *
 * @generated from message producerflow.appointment.v1.ListAppointmentsRequest
 */
export class ListAppointmentsRequest extends Message<ListAppointmentsRequest> {
  /**
   * Optional. Filter results by processing status.
   *
   * @generated from field: repeated producerflow.appointment.v1.ProcessingStatus processing_status = 1;
   */
  processingStatus: ProcessingStatus[] = [];

  /**
   * Optional. Maximum number of results to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. Token for fetching the next page.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListAppointmentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.ListAppointmentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processing_status", kind: "enum", T: proto3.getEnumType(ProcessingStatus), repeated: true },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAppointmentsRequest {
    return new ListAppointmentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAppointmentsRequest {
    return new ListAppointmentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAppointmentsRequest {
    return new ListAppointmentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAppointmentsRequest | PlainMessage<ListAppointmentsRequest> | undefined, b: ListAppointmentsRequest | PlainMessage<ListAppointmentsRequest> | undefined): boolean {
    return proto3.util.equals(ListAppointmentsRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.ListAppointmentsResponse
 */
export class ListAppointmentsResponse extends Message<ListAppointmentsResponse> {
  /**
   * List of appointments.
   *
   * @generated from field: repeated producerflow.appointment.v1.Appointment appointments = 1;
   */
  appointments: Appointment[] = [];

  /**
   * Token for fetching the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListAppointmentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.ListAppointmentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointments", kind: "message", T: Appointment, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAppointmentsResponse {
    return new ListAppointmentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAppointmentsResponse {
    return new ListAppointmentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAppointmentsResponse {
    return new ListAppointmentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAppointmentsResponse | PlainMessage<ListAppointmentsResponse> | undefined, b: ListAppointmentsResponse | PlainMessage<ListAppointmentsResponse> | undefined): boolean {
    return proto3.util.equals(ListAppointmentsResponse, a, b);
  }
}

/**
 * Request to terminate an appointment.
 *
 * @generated from message producerflow.appointment.v1.TerminateAppointmentRequest
 */
export class TerminateAppointmentRequest extends Message<TerminateAppointmentRequest> {
  /**
   * Required. ID of the appointment to terminate.
   *
   * @generated from field: string appointment_id = 1;
   */
  appointmentId = "";

  /**
   * Required. Reason for termination.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<TerminateAppointmentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.TerminateAppointmentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateAppointmentRequest {
    return new TerminateAppointmentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateAppointmentRequest {
    return new TerminateAppointmentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateAppointmentRequest {
    return new TerminateAppointmentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateAppointmentRequest | PlainMessage<TerminateAppointmentRequest> | undefined, b: TerminateAppointmentRequest | PlainMessage<TerminateAppointmentRequest> | undefined): boolean {
    return proto3.util.equals(TerminateAppointmentRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.TerminateAppointmentResponse
 */
export class TerminateAppointmentResponse extends Message<TerminateAppointmentResponse> {
  /**
   * Indicates whether the termination was successful.
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  constructor(data?: PartialMessage<TerminateAppointmentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.TerminateAppointmentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateAppointmentResponse {
    return new TerminateAppointmentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateAppointmentResponse {
    return new TerminateAppointmentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateAppointmentResponse {
    return new TerminateAppointmentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateAppointmentResponse | PlainMessage<TerminateAppointmentResponse> | undefined, b: TerminateAppointmentResponse | PlainMessage<TerminateAppointmentResponse> | undefined): boolean {
    return proto3.util.equals(TerminateAppointmentResponse, a, b);
  }
}

/**
 * Request to check appointment eligibility for a license.
 *
 * @generated from message producerflow.appointment.v1.CheckAppointmentEligibilityRequest
 */
export class CheckAppointmentEligibilityRequest extends Message<CheckAppointmentEligibilityRequest> {
  /**
   * Required. License number to check.
   *
   * @generated from field: string license_number = 1;
   */
  licenseNumber = "";

  constructor(data?: PartialMessage<CheckAppointmentEligibilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.CheckAppointmentEligibilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "license_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAppointmentEligibilityRequest {
    return new CheckAppointmentEligibilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAppointmentEligibilityRequest {
    return new CheckAppointmentEligibilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAppointmentEligibilityRequest {
    return new CheckAppointmentEligibilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAppointmentEligibilityRequest | PlainMessage<CheckAppointmentEligibilityRequest> | undefined, b: CheckAppointmentEligibilityRequest | PlainMessage<CheckAppointmentEligibilityRequest> | undefined): boolean {
    return proto3.util.equals(CheckAppointmentEligibilityRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.CheckAppointmentEligibilityResponse
 */
export class CheckAppointmentEligibilityResponse extends Message<CheckAppointmentEligibilityResponse> {
  /**
   * If not eligible, reasons will be returned.
   *
   * @generated from field: repeated string not_eligible_reasons = 1;
   */
  notEligibleReasons: string[] = [];

  constructor(data?: PartialMessage<CheckAppointmentEligibilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.CheckAppointmentEligibilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "not_eligible_reasons", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAppointmentEligibilityResponse {
    return new CheckAppointmentEligibilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAppointmentEligibilityResponse {
    return new CheckAppointmentEligibilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAppointmentEligibilityResponse {
    return new CheckAppointmentEligibilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAppointmentEligibilityResponse | PlainMessage<CheckAppointmentEligibilityResponse> | undefined, b: CheckAppointmentEligibilityResponse | PlainMessage<CheckAppointmentEligibilityResponse> | undefined): boolean {
    return proto3.util.equals(CheckAppointmentEligibilityResponse, a, b);
  }
}

/**
 * Request to get appointment fees.
 *
 * @generated from message producerflow.appointment.v1.GetAppointmentFeesRequest
 */
export class GetAppointmentFeesRequest extends Message<GetAppointmentFeesRequest> {
  /**
   * Required. License number to appoint.
   *
   * @generated from field: string license_number = 1;
   */
  licenseNumber = "";

  constructor(data?: PartialMessage<GetAppointmentFeesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetAppointmentFeesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "license_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppointmentFeesRequest {
    return new GetAppointmentFeesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppointmentFeesRequest {
    return new GetAppointmentFeesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppointmentFeesRequest {
    return new GetAppointmentFeesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppointmentFeesRequest | PlainMessage<GetAppointmentFeesRequest> | undefined, b: GetAppointmentFeesRequest | PlainMessage<GetAppointmentFeesRequest> | undefined): boolean {
    return proto3.util.equals(GetAppointmentFeesRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.GetAppointmentFeesResponse
 */
export class GetAppointmentFeesResponse extends Message<GetAppointmentFeesResponse> {
  /**
   * Total fee for the appointment in cents.
   *
   * @generated from field: int64 fee_in_cents = 1;
   */
  feeInCents = protoInt64.zero;

  constructor(data?: PartialMessage<GetAppointmentFeesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetAppointmentFeesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fee_in_cents", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppointmentFeesResponse {
    return new GetAppointmentFeesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppointmentFeesResponse {
    return new GetAppointmentFeesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppointmentFeesResponse {
    return new GetAppointmentFeesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppointmentFeesResponse | PlainMessage<GetAppointmentFeesResponse> | undefined, b: GetAppointmentFeesResponse | PlainMessage<GetAppointmentFeesResponse> | undefined): boolean {
    return proto3.util.equals(GetAppointmentFeesResponse, a, b);
  }
}

/**
 * Request to get termination fees.
 *
 * @generated from message producerflow.appointment.v1.GetTerminationFeesRequest
 */
export class GetTerminationFeesRequest extends Message<GetTerminationFeesRequest> {
  /**
   * Required. Appointment ID.
   *
   * @generated from field: string appointment_id = 1;
   */
  appointmentId = "";

  constructor(data?: PartialMessage<GetTerminationFeesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetTerminationFeesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTerminationFeesRequest {
    return new GetTerminationFeesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTerminationFeesRequest {
    return new GetTerminationFeesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTerminationFeesRequest {
    return new GetTerminationFeesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTerminationFeesRequest | PlainMessage<GetTerminationFeesRequest> | undefined, b: GetTerminationFeesRequest | PlainMessage<GetTerminationFeesRequest> | undefined): boolean {
    return proto3.util.equals(GetTerminationFeesRequest, a, b);
  }
}

/**
 * @generated from message producerflow.appointment.v1.GetTerminationFeesResponse
 */
export class GetTerminationFeesResponse extends Message<GetTerminationFeesResponse> {
  /**
   * Total fee for the termination in cents.
   *
   * @generated from field: int64 fee_in_cents = 1;
   */
  feeInCents = protoInt64.zero;

  constructor(data?: PartialMessage<GetTerminationFeesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.GetTerminationFeesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fee_in_cents", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTerminationFeesResponse {
    return new GetTerminationFeesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTerminationFeesResponse {
    return new GetTerminationFeesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTerminationFeesResponse {
    return new GetTerminationFeesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTerminationFeesResponse | PlainMessage<GetTerminationFeesResponse> | undefined, b: GetTerminationFeesResponse | PlainMessage<GetTerminationFeesResponse> | undefined): boolean {
    return proto3.util.equals(GetTerminationFeesResponse, a, b);
  }
}

/**
 * Represents an appointment for a license.
 *
 * @generated from message producerflow.appointment.v1.Appointment
 */
export class Appointment extends Message<Appointment> {
  /**
   * Unique identifier for the appointment.
   *
   * @generated from field: string appointment_id = 1;
   */
  appointmentId = "";

  /**
   * The license number associated with the appointment.
   *
   * @generated from field: string license_number = 2;
   */
  licenseNumber = "";

  /**
   * Type of appointment (e.g., up-front, registry).
   *
   * @generated from field: producerflow.appointment.v1.AppointmentType appointment_type = 3;
   */
  appointmentType = AppointmentType.UNSPECIFIED;

  /**
   * Eligibility status of the appointment (e.g., eligible, ineligible).
   *
   * @generated from field: producerflow.appointment.v1.EligibilityStatus eligibility_status = 4;
   */
  eligibilityStatus = EligibilityStatus.UNSPECIFIED;

  /**
   * Processing status of the appointment (e.g., in progress, appointed).
   *
   * @generated from field: producerflow.appointment.v1.ProcessingStatus processing_status = 5;
   */
  processingStatus = ProcessingStatus.UNSPECIFIED;

  /**
   * If ineligible or rejected, reasons will be listed here.
   *
   * @generated from field: repeated string not_eligible_reasons = 6;
   */
  notEligibleReasons: string[] = [];

  /**
   * Optional comments or notes related to the appointment.
   *
   * @generated from field: string comments = 7;
   */
  comments = "";

  /**
   * Total appointment fee in cents.
   *
   * @generated from field: int64 appointment_fee_in_cents = 8;
   */
  appointmentFeeInCents = protoInt64.zero;

  /**
   * Total termination fee in cents, if terminated or eligible for termination.
   *
   * @generated from field: int64 termination_fee_in_cents = 9;
   */
  terminationFeeInCents = protoInt64.zero;

  /**
   * Timestamp when the appointment was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 10;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp of the last update to the appointment.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 11;
   */
  updatedAt?: Timestamp;

  constructor(data?: PartialMessage<Appointment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "producerflow.appointment.v1.Appointment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "appointment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "license_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "appointment_type", kind: "enum", T: proto3.getEnumType(AppointmentType) },
    { no: 4, name: "eligibility_status", kind: "enum", T: proto3.getEnumType(EligibilityStatus) },
    { no: 5, name: "processing_status", kind: "enum", T: proto3.getEnumType(ProcessingStatus) },
    { no: 6, name: "not_eligible_reasons", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "comments", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "appointment_fee_in_cents", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "termination_fee_in_cents", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "created_at", kind: "message", T: Timestamp },
    { no: 11, name: "updated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Appointment {
    return new Appointment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Appointment {
    return new Appointment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Appointment {
    return new Appointment().fromJsonString(jsonString, options);
  }

  static equals(a: Appointment | PlainMessage<Appointment> | undefined, b: Appointment | PlainMessage<Appointment> | undefined): boolean {
    return proto3.util.equals(Appointment, a, b);
  }
}

