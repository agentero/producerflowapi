syntax = "proto3";

package producerflow.appointment.v1;

import "buf/validate/validate.proto";
import "google/protobuf/timestamp.proto";

// AppointmentService manages license appointments through NIPR.
//
// The appointment flow in NIPR is as follows:
// 1. A new appointment (or termination) is requested for a license number.
// 2. Some time later, NIPR processes the request and returns the final result.
//
// Since NIPR does not return results immediately, RequestAppointment and TerminateAppointment
// RPCs will return a processing status of IN_PROGRESS if the request is accepted by NIPR.
// When the appointment is finally processed by NIPR, ProducerFlow will notify via a webhook of
// the final result. Also, any call from this point on to ListAppointments or GetAppointment will
// also return the final result.
//
// Any call to this service must be authenticated using an API key in the request headers. The API key
// can be found in the ProducerFlow API key section of the ProducerFlow UI and it identifies the tenant
// that is making the request.
service AppointmentService {
  // Retrieves the details of an appointment by its ID.
  rpc GetAppointment(GetAppointmentRequest) returns (GetAppointmentResponse);

  // Retrieves the total fees associated with requesting an appointment. Fee amounts are represented
  // as integer values in cents. E.g. $10.34 is sent as 1034.
  rpc GetAppointmentFees(GetAppointmentFeesRequest) returns (GetAppointmentFeesResponse);

  // Retrieves the carriers that are available to appoint licenses for the tenant.
  rpc GetAppointableCarriers(GetAppointableCarriersRequest) returns (GetAppointableCarriersResponse);

  // Retrieves the total fees associated with terminating an appointment. Fee amounts are represented
  // as integer values in cents. E.g. $10.34 is sent as 1034.
  rpc GetTerminationFees(GetTerminationFeesRequest) returns (GetTerminationFeesResponse);

  // Lists appointments for the tenant, optionally filtered by processing status.
  rpc ListAppointments(ListAppointmentsRequest) returns (ListAppointmentsResponse);

  // Returns a list of licenses that are eligible to be appointed.
  rpc ListEligibleLicenses(ListEligibleLicensesRequest) returns (ListEligibleLicensesResponse);

  // Requests a new appointment for a license that is eligible to be appointed. The simpler way
  // to do this is to call ListEligibleLicenses to get a list of licenses that are eligible to be
  // appointed. Then, call RequestAppointment for the licenses in the list that you want to appoint.
  //
  // If the request is accepted by NIPR, the appointment will have IN_PROGRESS processing status.
  // If rejected, it will have REJECTED status and reasons will be provided in not_eligible_reasons.
  rpc RequestAppointment(RequestAppointmentRequest) returns (RequestAppointmentResponse);

  // Terminates an existing appointment by ID, providing a reason.
  rpc TerminateAppointment(TerminateAppointmentRequest) returns (TerminateAppointmentResponse);
}

// Request to create a new appointment.
message RequestAppointmentRequest {
  // Required. The ID of the license to appoint.
  string license_id = 1 [(buf.validate.field).string.min_len = 1];

  // Required. The ID of the carrier to appoint the license with.
  string carrier_id = 2 [(buf.validate.field).string.min_len = 1];
}

message RequestAppointmentResponse {
  // The ID of the created appointment.
  string appointment_id = 1;
  // Processing status of the appointment request.
  ProcessingStatus processing_status = 2;
  // If the appointment was rejected or ineligible, these reasons explain why.
  repeated string not_eligible_reasons = 3;
}

// Request to retrieve an appointment by ID.
message GetAppointmentRequest {
  // Required. The ID of the appointment to retrieve.
  string appointment_id = 1 [(buf.validate.field).string.min_len = 1];
}

message GetAppointmentResponse {
  // The appointment details.
  Appointment appointment = 1;
}

// Request to list appointments, optionally filtered by processing status.
message ListAppointmentsRequest {
  // Optional. Filter results by processing status.
  repeated ProcessingStatus processing_status = 1;
  // Optional. Maximum number of results to return.
  int32 page_size = 2 [(buf.validate.field).int32 = {
    gte: 1
    lte: 100
  }];
  // Optional. Token for fetching the next page.
  string page_token = 3;
}

message ListAppointmentsResponse {
  // List of appointments.
  repeated Appointment appointments = 1;
  // Token for fetching the next page of results.
  string next_page_token = 2;
}

// Request to terminate an appointment.
message TerminateAppointmentRequest {
  // Required. ID of the appointment to terminate.
  string appointment_id = 1 [(buf.validate.field).string.min_len = 1];
  // Required. Reason for termination.
  string reason = 2 [(buf.validate.field).string.min_len = 1];
}

message TerminateAppointmentResponse {
  // Indicates whether the termination was successful.
  bool success = 1;
}

// Request to retrieve a list of licenses that are eligible to be appointed.
message ListEligibleLicensesRequest {
  // The applicant is the producer or agency with licenses eligible to be appointed.
  oneof applicant {
    string producer_id = 1 [(buf.validate.field).string.uuid = true];
    string agency_id = 2 [(buf.validate.field).string.uuid = true];
    option (buf.validate.oneof).required = true;
  }
}

message ListEligibleLicensesResponse {
  // List of licenses that are eligible to be appointed.
  repeated License licenses = 1;
}

// Request to get appointment fees.
message GetAppointmentFeesRequest {
  // Required. License number to appoint.
  string license_number = 1 [(buf.validate.field).string.min_len = 1];
}

message GetAppointmentFeesResponse {
  // Total fee for the appointment in cents.
  int64 fee_in_cents = 1;
}

// Request to get termination fees.
message GetTerminationFeesRequest {
  // Required. Appointment ID.
  string appointment_id = 1 [(buf.validate.field).string.min_len = 1];
}

message GetTerminationFeesResponse {
  // Total fee for the termination in cents.
  int64 fee_in_cents = 1;
}

message GetAppointableCarriersRequest {}

message GetAppointableCarriersResponse {
  // The list of carriers that are available to be appointed.
  repeated Carrier carriers = 1;
}

// Represents a carrier that is available to be appointed.
message Carrier {
  // The ID of the carrier.
  string carrier_id = 1;

  // The name of the carrier.
  string name = 2;

  // The NPN of the carrier.
  string npn = 3;

  // The state of the carrier.
  string fein = 4;
}

// Represents an appointment for a license.
message Appointment {
  // Unique identifier for the appointment.
  string appointment_id = 1;

  // The license number of the license being appointed.
  License license = 2;

  // Type of appointment (e.g., up-front, registry).
  AppointmentType appointment_type = 4;

  // Eligibility status of the appointment (e.g., eligible, ineligible).
  EligibilityStatus eligibility_status = 5;

  // Processing status of the appointment (e.g., in progress, appointed).
  ProcessingStatus processing_status = 6;

  // If ineligible or rejected, reasons will be listed here.
  repeated string not_eligible_reasons = 7;

  // Optional comments or notes related to the appointment.
  string comments = 8;

  // Total appointment fee in cents.
  int64 appointment_fee_in_cents = 9;

  // Total termination fee in cents, if terminated or eligible for termination.
  int64 termination_fee_in_cents = 10;

  // Timestamp when the appointment was created.
  google.protobuf.Timestamp created_at = 11;

  // Timestamp of the last update to the appointment.
  google.protobuf.Timestamp updated_at = 12;
}

// Eligibility status of the appointment.
enum EligibilityStatus {
  ELIGIBILITY_STATUS_UNSPECIFIED = 0;
  ELIGIBILITY_STATUS_ELIGIBLE = 1;
  ELIGIBILITY_STATUS_INELIGIBLE = 2;
}

// Processing status of the appointment.
enum ProcessingStatus {
  PROCESSING_STATUS_UNSPECIFIED = 0;
  PROCESSING_STATUS_IN_PROGRESS = 1;
  PROCESSING_STATUS_APPOINTED = 2;
  PROCESSING_STATUS_TERMINATED = 3;
  PROCESSING_STATUS_REJECTED = 4;
  PROCESSING_STATUS_MISSING_LICENSE = 5;
}

// Type of appointment.
enum AppointmentType {
  APPOINTMENT_TYPE_UNSPECIFIED = 0;
  APPOINTMENT_TYPE_REGISTRY = 1;
  APPOINTMENT_TYPE_UP_FRONT = 2;
  APPOINTMENT_TYPE_JUST_IN_TIME = 3;
}

message License {
  // The ID of the license.
  string license_id = 1;

  // The license number.
  string license_number = 2;

  // The owner of the license, it can be an agency or a producer.
  oneof license_owner {
    string producer_id = 3 [(buf.validate.field).string.uuid = true];
    string agency_id = 4 [(buf.validate.field).string.uuid = true];
  }

  // The two-letter state code of the license.
  string state = 5;

  // The license class.
  string license_class = 6;
}
